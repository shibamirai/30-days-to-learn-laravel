# [29. Jobs, Tags, TDD, Oh My!]

[このレッスンのソースコードを見る](https://github.com/laracasts/pixel-position/commit/e2f62154f0e102eba6d221269f728d19c67370ff)

## ジョブに、タグに、TDDに、やることがいっぱいだ

00:04
All right everybody. Welcome to day 29.
> それではみなさん、29日目へようこそ。

00:08
We're getting close, two videos to go.
> 動画も残り２本となりました。

00:10
And if you want me to be frank, I'm getting a little stressed out because we have so much to cover.
> 正直言うと、カバーすべき内容が多すぎて、少しストレスが溜まっています。

00:14
Alright, so like I sail at the end of the last episode, we are mostly done with the front end portion.
> さて、前回の最後に言ったように、フロントエンドの部分はほとんど終わりました。

00:20
Well, we still have to construct a form later, but yeah, most of the boring stuff, quote unquote, is all done.
> まあこの後、まだフォームを構築しなければいけませんが、いわゆる退屈なことはほとんどは終わりました。

00:26
So in this video, we will move on to the architecture of the application.
> この動画では、アプリケーションの構造に入ります。

00:31
Now, I know already that it's an employer who will publish a job.
> さて、求人を公開するのは雇用主だということはわかっています。

00:35
So I'm going to start with a migration to create that table.
> ですからマイグレーションから始めてそのテーブルを作りましょう。

00:38
Create employer's table.
> マイグレーションファイルを作ります。

00:40
All right? Create employer's table.
> できたらそれを開きます。

00:43
And yeah, let's see, an employer has a name that'll be a string.
> 見てみましょう。雇用主には名前があります。これは文字列ですね。

00:48
They have a logo. So we will store a path to that logo.
> ロゴも持っています。そのロゴのパスを保持するようにしましょう。

00:52
And then also an employer belongs to a user, right?
> それから雇用主はユーザに属していますね。

00:56
A user signs up, they create an employer and it is the employer who publishes the job.
> ユーザ登録をしてから雇用主を作成し、その雇用主が求人を公開します。

01:01
Alright, let's do a foreign ID for a user and of course we can clean this up.
> では、`foreignIdFor()`でUserに関連づけましょう。もちろんこれはインポートして綺麗にします。

01:06
Alright, let's migrate the database.
> では、データベースのマイグレーションを行いましょう。

01:09
Php artisan migrate.
> `php artisan migrate`を実行します。

01:12
All right. So we have three tables that Laravel ships with out of the box, and then our new employers table.
> はい、これでLaravelが最初から用意している３つのテーブルと新しく雇用主テーブルができました。

01:18
If I switch to TablePlus, let's open it.
> TablePlusで開いてみましょう。

01:20
It's an SQLite connection.
> これはSQLiteとのコネクションですね。

01:23
I'll give it a name and the path. So here's our app. It's going to go into database, database.sqlite.
> 名前をつけてパスを指定しましょう。ここが私たちのアプリのディレクトリで、このdatabaseフォルダの中にあるdatabase.sqliteです。

01:32
Save it. And yeah, now we have our new employers table.
> 保存します。新しい求人テーブルができていますね。

01:36
Okay, so while we are here though, yeah, jobs and job_batches and failed_jobs. You'll remember throughout the course, because Laravel has a concept of queue jobs that kept interfering with our concept of a job listing.
> ここでついでにこれもやっておきましょう。'jobs'に'job_batches'に'failed_jobs'テーブルがありますね。このコースを通してずっと覚えているかと思いますが、Laravelにはキューのジョブという概念があり、私たちの求人のジョブという概念とずっと衝突しています。

01:51
So yeah, I don't want any interference. So what I'm going to do is change these default table names.
> 衝突されていると困るので、これらのデフォルトのテーブルの名前を変更したいと思います。

01:57
Go into your config directory down to queue and let's have a look.
> configディレクトリの中にあるqueueファイルを見てみましょう。

02:02
I'm just going to look for table.
> テーブルを探しているんですが、

02:03
Yeah, so for the database connection for our queue driver, the default table name is jobs.
> ありました。キュードライバーのデータベースコネクションのところにあるデフォルトのテーブル名がjobsになっています。

02:09
So why don't we change this to queued jobs or again, we could store this directly within your environment file.
> ではこれを'queue_jobs'に変更しましょう。または以前お話したように、この環境変数を環境ファイルに直接保存することもできます。

02:17
All right, let's do another table search.
> 他のテーブルも探しましょう。

02:19
Ah, yeah, job batches. We didn't really go over this. It's a slightly higher level concept, but nonetheless I'm going to use the same convention here.
> job_batchesがありました。これについては少し高度な話になるのであまり深入りしませんが、これにも同じことをしておきます。

02:26
It'll now be called queued job batches.
> 'queued_job_batches'という名前にします。

02:29
And I think there's one more. Yeah.
> もう一つあったはずです。ありました。

02:31
So if a queued job runs but if fails for some reason, it needs to be stroed, right, so that we can reference it later and retry it later.
> もしキューのジョブを実行したときにそれが何らかの理由で失敗したら、それを保存しておかないといけませんよね。後でそれを見てやり直しできるようにです。

02:39
So that table is called failed jobs by default. Now it's going to be queued failed jobs.
> ですからこのテーブルは、デフォルトでは'failed_jobs'と呼ばれます。今はこれを'queued_faild_jobs'にします。

02:46
Alright, so now we just have to update the migration itself.
> では今度は、マイグレーションファイル自身を更新する必要があります。

02:49
So this is the migration that Laravel ships with, create jobs table.
> これがLaravelに最初から用意してあるマイグレーションファイル、create_jobs_tableです。

02:53
And yeah, let's start by renaming it to create queued jobs table.
> では、この名前を’create_queued_jobs_table'に変更することから始めましょう。

02:58
And then I will update the table names, queued jobs, queued_job_batches, and then finally queued failed jobs.
> それからテーブル名を更新します。'queued_jobs', 'queued_job_batches', それから最後に'queued_failed_jobs'です。

03:07
Okay, let's refresh our migrations.
> ではマイグレーションをやり直しましょう。

03:09
php artisan migrate fresh.
> `php artisan migrate:fresh`

03:13
And now if I switch back to TablePlus and give this a refresh.
> そして、TablePlusに戻って更新してみると、

03:16
Alright, now, yeah, there won't be any interference whatsoever with our job model.
> もう私たちのJobモデルと衝突するものは何もありません。

03:21
Okay, so let's do this.
> 続いてこれを行いましょう。

03:23
We did this in two steps, didn't we? We created a migration for the employer's table and now I'm going to create a model for the employer.
> 私たちはこの作業を２つのステップに分けてやっています。まず雇用主のテーブルのマイグレーションを作りました。そして今から雇用主のモデルを作ろうとしています。

03:31
But don't forget, if I do help on make model, we can generate these things all in one go, including the migration, including a factory, including a controller, or if we pass the dash a flag, it makes the migration, the model, the seeder, the factory, the policy, the resource controller, and a form request.
> でも忘れないでください。make:modelのヘルプを見ると、これらのものをすべて一度に生成することができることが分かります。マイグレーションもファクトリーもコントローラーも作れます。または-aフラグを使えば、マイグレーションに、モデルに、シーダーに、ファクトリーに、ポリシーに、リソースコントローラーに、フォームリクエストまで作れます。

03:50
Yeah, there's a lot here, but it really does save a bunch of time.
> はい、たくさんありますが、本当にたくさんの時間が節約できます。

03:53
Okay. But anyways, because we already created the migration, this time let's build the model and I will select the ones that I need.
> でもとにかく、私たちはすでにマイグレーションを作っているので、今はモデルと、いくつか必要なものを選択して作成します。

04:01
So dash c for controller, f for factory, dash s for a database seeder, and then I also want a policy.
> -cでコントローラー、fでファクトリー、-sでデータベースシーダー、それからポリシーも欲しいですね。

04:10
Cool, so now we get five files with a single command, which is pretty cool.
> 1つのコマンドで5つのファイルができました。とてもクールですね。

04:15
Okay, next up, let's focus on jobs.
> では次は、求人にフォーカスを当てましょう。

04:18
And this time we'll do it all in one go.
> 今度は一度にすべて行います。

04:20
Php artisan make model job dash all.
> `php artisan make:model Job --all`を実行します。

04:25
And yeah, now we get all of these files for free.
> はい、これらのファイルがすべて無料で手に入りました。

04:28
And yeah, keep in mind if it turns out that there's one, maybe form request that you're not going to use, just hit the delete key. No problem there.
> それから覚えておいてください。このフォームリクエストのように使う予定のないものがあれば、単に削除してしまってください。それで問題ありません。

04:35
Alright, so let's go into our migration, create jobs table, and let's see, let's think through.
> それでは作成されたマイグレーション、create_jobs_tableを開いてください。これを見て考えてみましょう。

04:42
To publish a job, we need to provide the title of the job, right? What's the job title?
> 求人を公開するには、タイトルが必要ですね。求人のタイトルは何でしょうか？

04:48
Next, what is the salary for the job?
> 次に給与はいくらでしょうか？

04:51
And yet, once again, we're going to be pretty generic here. I don't want to deal with, with currencies and stuff like that.
> 繰り返しになりますが、ここは何でもありにしておきます。通貨が何だといったようなことは扱いたくありません。

04:58
So you can provide whatever you want for that field.
> ということで、このフィールドには何でも記入できるようにします。

05:00
Alright, next, another string. What is the location for this job?
> では、次も文字列です。勤務地はどこですか？

05:04
Is it remote or do you have to be in Winter Park, Florida? It just depends. So you need to specify that.
> リモートワークですか？それともフロリダのウィンターパークにいる必要がありますか？仕事によるのでそれを特定する必要があります。

05:10
Alright, next. What is the, what should we call this? the type of work. Is it full-time or part-time?
> それでは次です。どのように言えばいいのかな、どんな働き方ですか？フルタイムですか？パートタイムですか？

05:18
And maybe type isn't the right term. Maybe schedule? That's not quite right either. Why don't we go schedule though.
> これにtypeという用語を使うのは変ですね。スケジュールでしょうか？これも違うような気がしますが、スケジュールにしておきましょうか。

05:24
It could be full-time or part-time and we'll set a default of full-time.
> ここはフルタイムかパートタイムになって、デフォルトではフルタイムにしておきます。

05:29
Yeah, if you want, this could be an enum, but I don't know, sometimes that's a little annoying to work with on the database level. So I will skip that.
> これをEnumにすることもできますが、データベースでEnumを扱うのは少し面倒くさいことが多いので、ここではやりません。

05:36
Alright, next up. When you publish a job, you need to provide a link to your actual job details page.
> では次です。求人を公開するときは、実際の求人の詳細ページへのリンクを提供する必要があります。

05:42
Beleive it or not, that's how it often works.
> 信じられないかもしれませんが、そうしてあることが多いです。

05:44
You publish your job to some kind of aggregate platform, but then it ultimately directs you to your own website where you provide more details.
> 求人をどこかの統合プラットフォームに公開しつつ、最終的には自身のウェブサイトに誘導して詳細情報を提供します。

05:53
So this will be a URL to the actual job listing.
> これがその実際の求人ページのURLになります。

05:56
And then, well, here's another thing.
> それから、もう一つ別のカラムです。

05:58
I don't know if we're going to implement this, but yeah, you could imagine allowing users to pay more to have their job listing featured at the top.
> これを実装するかどうかは分かりませんが、追加料金を払えば、その求人を先頭にフィーチャーさせることができるという機能が考えられますね。

06:05
So we need some way to determine if a job should be featured or not.
> そのためには、その求人がフィーチャーされるのかどうかを判定する必要があります。

06:10
So with that in mind, let's make that a boolean. It'll be featured, but the default is false.
> それを考えると、これはブール値にしましょう。'featured'という名前にして、デフォルト値はfalseです。

06:16
And then finally, the relationship. A job belongs to an employer, right?
> それから最後にリレーションです。求人は雇用主に属していますね。

06:21
So let's set a foreign ID for the employer.
> 雇用主の外部キーをセットしましょう。

06:24
And then onse again I will import that.
> これもまたインポートしておきます。

06:27
Alright, that looks good to me.
> これでよさそうです。

06:29
Let's migrate our database.
> データベースをマイグレーションしましょう。

06:31
Back to TablePlus, give it a refresh.
> TablePlusに戻って更新します。

06:33
Now we have users, we have jobs and we have employers. Very cool.
> これでusersテーブルとjobsテーブル、そしてemployersテーブルができました。いいですね。

06:38
So now I'm going to set up those relationships.
> ではこれから、これらのリレーションをセットしていきます。

06:41
Let's start with employer.
> 雇用主から始めましょう。

06:43
An employer belongs to a user.
> 雇用主はユーザに属しています。

06:45
So return, this is a belongs to relationship. And then we reference the associated model.
> returnに続いて、これはbelongsToリレーションですね。それから関連するモデルを参照します。

06:51
And if you want you can add a return type or you can omit it. Just depends on what system you want to follow.
> 必要なら戻り値の型をつけることもできますし省略することもできます。あなたがどういう方針に従いたいかによります。

06:57
Alright, now let's do the inverse.
> 逆からの関連もやりましょう。

06:59
So in this case, the user is actually like the representative for the employer.
> この場合、このユーザは実際には雇用主を表していると言えます。

07:03
So it's not a belongs to relationship, it's actually a has one relationship.
> つまりbelongsToリレーションではなく、hasOneリレーションになります。

07:09
So a user has one employer, like so.
> ユーザは雇用主を１つ持っているというように書くことができます。

07:15
All right, next let's switch over to job.
> では次はJobに移りましょう。

07:18
So what are the relationships for a job?
> 求人の関連は何でしょうか？

07:20
Well, as we discussed, a job belongs to an employer, right?
> 前に話したように、求人は雇用主に属していますよね。

07:26
Of course it does.
> その通り、雇用主に属しています。

07:28
Alright, next, yeah, once again, let's do the inverse.
> では、次はまたこの逆の関係ですね。

07:30
If I have an employer instance and I want to see all jobs associated with that one employer and no one else, well let's do that.
> 雇用主のインスタンスがあったとしたら、他の誰でもなくその雇用主に関連した求人を見たいですよね。それをやりましょう。

07:38
Jobs. And this is going to be a has many relationship.
> jobsメソッドを定義します。これはhasManyリレーションになります。

07:44
An employer has many jobs.
> 雇用主はたくさんの求人を持っています。

07:47
And again, if you want you can add a type here.
> 繰り返しますが、ここに型をつけることもできます。

07:50
Just make sure that you import it at the top here.
> ちゃんとインポートできているか、ここの上のところで確かめておきますね。

07:54
Now, real quick, we're making good progress, but yeah, I do want to introduce testing at least a little bit.
> ここでちょっといいでしょうか。私たちはとても順調に進んでいます。ですが、ここでテストについて少しだけご紹介したいと思います。

08:00
It's a tricky thing.
> これは厄介なものです。

08:02
Testing is a key comonent to building applications these days, but for a beginner level course it slows things down dramatically.
> 近年のアプリケーション構築においてテストは重要な要素になっていますが、初級レベルのコースでそれを扱うと、劇的に進みが遅くなります。

08:10
But yeah, nonetheless, we want to discuss it at least a bit.
> ですが、そうであっても、ほんの少しだけでも話しておきたいと思います。

08:14
So I'm going to write tests for this entire project like I would do in real life, but we'll write some to give you the general approach. All right, let's do that now.
> このプロジェクト全体のテストは、私が普段やっているように書いていくつもりですが、いつくかのテストは一般的なアプローチ方法をお見せするために書いてみます。それを今やってみましょう。

08:23
So let's do this. Before I can write some test, I first want to flesh out my database factories.
> このようにします。実際にテストを書き始める前に、まずはデータベースファクトリーを使えるようにしていきたいと思います。

08:29
So let's go into factories and build these out.
> というわけで、factoriesディレクトリに移動してこれらを作っていきます。

08:31
All right, so let's see. An employer has a fake name.
> では、見ていてください。雇用主にはフェイクの名前を用意します。

08:37
It has a fake logo. So let's see if there's some kind of image URL. Yeah, I think that'll work.
> フェイクのロゴもあります。画像のURLのようなものがないか探してみましょう。ありました。これでいいでしょう。

08:44
And then finally, an employer belongs to a user, right? So let's reference a user factory.
> 最後に、雇用主はユーザに属していますね。ですからユーザのファクトリを参照しましょう。

08:50
Alright, that's done. Now into job factory, and a job has a title.
> はい、できました。今度はJobFactoryです。求人にはタイトルがあります。

08:55
So I believe Faker has a job title property, which is pretty cool.
> FakerにはjobTitleプロパティがあったはずです。これは本当にクールです。

08:59
They have a salary. And here's what I'll do in this case. This is a cool little tip.
> 給与もあります。ここではこんな風に実装しましょう。うまいやり方をお見せします。

09:04
There is a random element method where you can pass an array and faker will just choose a random item from that array.
> randomElementというメソッドがあり、配列を渡すとfakerはそこからランダムに要素を選びます。

09:10
So for example, you could say 50,000 USD like we've been doing, 90,000 USD or 150,000 USD.
> ですから例えば、これまでやってきたように50,000ドルや90,000ドル、150,000ドルというように書くことができます。

09:19
So now every single item will be one of these three.
> これですべてのアイテムは、これらの３つのうちのどれかの値になります。

09:27
All right, next we said location.
> では、次は勤務地です。

09:29
I'm just going to hard code that to remote. And also that's an important thing to realize.
> これは「リモート」とハードコーディングしましょう。これは重要なことでもあるので是非分かっておいて欲しいのですが、

09:33
It doesn't always have to be random, fake data. If you need to hard code it, that's fine, it doesn't matter.
> 常にランダムな仮のデータでなければならないということはありません。ハードコーディングする必要があるのであればそうしてください。それで構いません。

09:38
Next, we have schedule and we'll set that to full time or again, if you want it random, use random element.
> 次はスケジュールです。これは「フルタイム」にしましょう。もしくはこれもランダムにしたければ、randomElementを使ってください。

09:44
Next, we need a URL to the job listing page on the employer's website. So we'll do fake URL.
> 次は、雇用主のサイトにある求人ページへのURLが必要です。フェイクのURLを使いましょう。

09:50
Is the job featured? We're just going to always set it to false unless you override it.
> この求人はフィーチャーされているのかどうか。これはあとから変更しないかぎり常にfalseにセットしておきましょう。

09:56
And then finally, yeah, the relationship, employer id. So we can say employer factory.
> それから最後にリレーション、employer_idです。Employerのfactoryが使えます。

10:05
All right, so let's clean that up and we're all set.
> はい、ここの警告を修正したら準備完了です。

10:08
Okay, so now we can write some tests for this.
> これでテストを書いていくことができます。

10:10
So let's come down into phpunit.xml.
> 下にあるphpunit.xmlを開きましょう。

10:14
So keep in mind even though we're using a test framework called pest, pest is a wrapper around PHPUnit.
> 私たちはPestというテストフレームワークを使っていますが、PestはPHPUnitのラッパーだということを頭に入れておいてください。

10:20
So that's why we can visit a phpunit.xml file to configure how Pest is going to behave, because Pest is just deferring to PHPUnit. It's a wrapper.
> だからphpunit.xmlファイルを開いてPestの動きを設定することができます。PestはPHPUnitに処理を受け渡しているだけの単なるラッパーです。

10:31
Anyways, you can see some of these environment variables that are set.
> とにかく、これら環境変数のいくつかに値がセットされているのが分かります。

10:34
These are like overrides when you're in a testing environment.
> テスト環境では、これらの値で環境変数を上書きするようです。

10:38
So I'm going to set up the database connection to also be SQLite, but I can set to the database itself to not be a file, but instead memory.
> ということで、データベース接続はここでもSQLiteに設定しますが、データベース自身はファイルではなくメモリに設定します。

10:48
And yeah, you won't always reach for this, but for small little projects like this, it's going to be perfect and super fast.
> いつもこの設定にするということはないでしょうが、このような小さなプロジェクトにはぴったりで動作も速いです。

10:55
Next, notice other things like sending mail or dealing with queues, yeah, all of that is effectively turned off.
> 次です。メール送信やキューの処理のような他のことは、ここでオフにすることができるようになっています。

11:01
We don't actually want to deliver an email when we are performing a test.
> テスト中に実際にメールが送信されてほしくはありません。

11:05
We just want to assert that an email was sent.
> メールが送信されたと言いたいだけです。

11:08
So in these situations we use the array driver rather than SMTP or postmark or something like that.
> そのような時には、SMTPやPostmarkなどではなくarrayドライバーを使います。

11:15
Alright, let's create a test.
> ではテストを作成しましょう。

11:17
Php artisan make test, I am testing my jobs, and now what kind feature or unit?
> `php artisan make:test`を実行します。テスト対象はJobです。その次の質問は、フィーチャーテストとユニットテストのどちらですか？

11:24
This can often be confusing.
> ここは悩むところです。

11:26
Think of a feature test as testing a wide spectrum of your application.
> フィーチャーテストはアプリケーションを広範囲にわたってテストすることだと考えてください。

11:31
Like this. When I visit such and such page, I expect to see that.
> こんな感じです。どこそこのページにアクセスしたら、これが表示されて欲しいとか、

11:35
Or when I make a post request to this controller, then validation should occur and I should see such and such in the database.
> または、このコントローラにPOSTリクエストを送信すると、バリデーションしてからデータベースがこうこうこういう風になるというようなテストです。

11:42
Think about it. That's testing a very wide range of your project versus a unit test, which is far more narrow.
> 考えてみてください。そのようなテストはプロジェクトの広範囲にわたるものになりますが、それに対してユニットテストは、非常に狭い範囲になります。

11:49
When I instantiate this class and I call that method, then I expect such and such in response.
> このクラスをインスタンス化してあのメソッドを呼ぶと、結果がこうなって欲しいという感じです。

11:55
And yeah, how narrow that ends up being differs based on the community.
> 狭いというのがどれくらいの範囲を指すのかは、コミュニティによって当然異なります。

12:00
So for example, would testing an eloquent model that hits the database, is that a unit test?
> 例えば、データベースを参照するEloquentモデルのテストはユニットテストでしょうか？

12:05
Some people say absolutely not. I say sure, who cares?
> 絶対に違うと言う人もいますが、私はそうだと思います。どっちだっていいんです。

12:09
But again, just make up your own mind.
> 自分で決めたらいいことです。

12:12
In our case, we are working with quote unquote unit test.
> 私たちのケースでは、「ユニットテスト」ということで進めていきましょう。

12:15
Okay? So let's open that up.
> いいですか？それではこのファイルを開きましょう。

12:17
It will be within your tests directory and unit. And now we have our new job test.
> このファイルはtestsディレクトリの下のUnitディレクトリにあります。新しくJobTestができています。

12:22
Now we already have an example here.
> 既に例が用意されていますね。

12:24
Expect true to be true, nice and readable.
> 「trueがtrueであることを期待します」読みやすくていいですね。

12:27
Let's run it. php artisan test.
> 実行してみましょう。`php artisan test`。

12:31
Okay, so we have the example test that Laravel ships with, and if we want we can go ahead and delete those.
> Laravelに最初から用意されているExampleTestがありますが、これは削除してしまって構いません。

12:38
Or just the one for unit for now.
> これでUnitの中身は１つだけです。

12:40
And yeah, the one we care about here is our job test. And of course it passes.
> はい、これでテストは私たちのJobTestだけになりました。もちろんこのテストは合格します。

12:45
But if we change this, expect true to be false, of course that's going to fail.
> ですが、これを「trueがfalseであることを期待します」に変更すると、当然これは失敗するでしょう。

12:52
So if I run it again, now we get red.
> もう一度実行してみると、今度は赤くなりました。

12:56
All right, let's review a few examples.
> それでは、いくつか例を見てみましょう。

12:59
Let's say a job belongs to an employer.
> 求人は雇用主に属していることをテストしてみましょう。

13:02
So I could say test it belongs to an employer, but as it turns out with pest, we can use this function name of test or we can use an alternative alias, which is it.
> 'それは雇用主に属している'ことをテスト(test)する、と書くことができます。ですがPestでは、このtestという名前の関数の代わりに別のエイリアスを使うことができます。それがこれです。

13:14
And you can switch between those based upon how you want to write out your tests.
> どちらを使うかは、あなたがどのようにテストコードを書きたいかによって選ぶことができます。

13:19
So notice I'm saying test that it belongs to an employer, that's great.
> 今は'それは雇用主に属している'ことをテスト(test)する、と書いています。これはこれでいいですね。

13:23
Or I could say it belongs to an employer. Both do the exact same thing.
> または、それ(it)は'雇用主に属している'、と書くこともできます。どちらの書き方でもやることは全く同じです。

13:29
So how would I check this?
> さて、これはどうやってチェックしましょうか？

13:31
Well, and this is usually a three step process, we often call it Arrange, Act, Assert, AAA.
> これは通常３つのプロセスに分かれます。私たちはよく、Arrange(準備して)、Act(実行して)、Assert(主張する)で'AAA'と呼んでいます。

13:38
Like this. Begin by arranging the world, creat the world in order to run your test.
> このような感じです。環境の準備から始めます。テストを実行するための環境を作ります。

13:44
Next, act. Perform some kind of action.
> 次は実行です。何かしらのアクションを実行します。

13:47
Finally, assert. What did you expect to happen as a result of that assertion?
> 最後に主張です。主張に対して、何が起こると期待していましたか？

13:53
All right, so I'll show you an example.
> 例をお見せしましょう。

13:54
It belongs to an employer. How do I arrange the world here?
> 「それは雇用主に属している」そのような環境をここでどうやって準備しましょうか？

13:57
Well, if it belongs to an employer, then I probably need an employer to perform this action, right?
> それが雇用主に属しているのであれば、このアクションを実行するのに雇用主が必要ですよね。

14:04
Let's use a factory for that, employer factory create.
> ではファクトリーを使いましょう。`Employer::factory()->create()`。

14:09
Alright, next. We are using it, it refers to a job, but I don't have a job currently. So let's do that as well.
> 次です。私たちはit関数を使っており、このitは求人を意味していますが、ここにはまだその求人がありません。これも同じようにしましょう。

14:16
Let's say job equals job factory create.
> `$job = Job::factory()->create()`とします。

14:20
Now when I run this, it is true, it'll set up its own relationship to an employer.
> これを実行すれば、内部で雇用主とのリレーションがセットされることになっていたはずですね。

14:25
But for this particular test, I want to be a little more explicit.
> ですがこのテストでは、もう少し明示的にセットしたいと思います。

14:29
So if I ever want to override anything declared within the factory, then I pass that as an array to the create method.
> ファクトリーの中で定義されたものを上書きしたければ、それを配列にしてcreateメソッドに渡します。

14:36
So in our case, I want to override employer like so.
> この場合は、このようにして雇用主を上書きしたいと思います。

14:41
Okay, and while we're here, let's clean things up.
> これでいいですね。ついでにコードを整理しておきましょう。

14:44
All right. So now step one, arrange is complete. Next up perform an action.
> これでステップ１、準備が完了しました。次はアクションの実行です。

14:49
So this is where I interact with the code base in the way that I want, in our case job employer.
> ここでテスト対象のソースコードとのやりとりを行います。この場合は$job->employerですね。

14:55
Okay? So often your action and your assertion will be separate, but in this particular case we can group them into one.
> いいですか？Action(実行)とAssertion(主張)は別々の場合が多いですが、この件の場合は１つにまとめることができます。

15:02
Arrange, oh I'm sorry, act and assert.
> Arrange(準備)、間違えました、Act(実行)とAssert(主張)です。

15:05
All right, so I could say expect job employer to be this like you see here.
> ここには、求人の雇用主がここにあるものと同じだとexpect(期待する)と書くことができます。

15:11
So here's what we could do.
> ということでこのようにします。

15:12
Job employer is employer. We’ve learned about that method many episodes ago.
> `$job->employer->is($employer)`。このメソッドはいくつか前のエピソードで学びました。

15:17
I expect that to be true.
> これがtrueであることを期待します。

15:21
So yeah, if the is() method is new to you, it's checking if what you pass here is the current instance.
> is()メソッドを知らない人に説明すると、これは引数で渡したものが自分自身のインスタンスと一致するかどうかを調べるものです。

15:27
So that will either return true or false.
> ですからこれはtrueかfalseを返します。

15:29
In our case, we expect it to be true.
> このケースではtrueであることを期待します。

15:32
All right, let's run our test, php artisan test.
> それではテストを実行してみましょう。`php artisan test`.

15:36
But it fails for a confusing reason.
> しかしこれは紛らわしい理由で失敗します。

15:39
A facade root has not been set.
> ファサードルートがセットされていません。

15:41
Alright, so ultimately what's happening here is the Laravel framework hasn't really loaded, because this is being treated as a sort of raw naked unit test.
> 結局のところ、ここで起こったことは、Laravelフレームワークがちゃんとロードされていなかったということです。なぜならこれは、素のユニットテストとして扱われているからです。

15:51
But I, I do want to interact with Laravel and Eloquent in the database.
> ですがわたしは、LaravleとデータベースのEloquentを使ってテストを行いたいのです。

15:55
So if I go into the Pest php file, this is sort of like the configuration file for your tests.
> ということで、Pest.phpファイルを開きます。これはテストのための設定ファイルのようなものです。

16:01
And right at the top, you can see use this root parent class in the feature directory.
> この上のところで、Featureディレクトリにあるこのルートの親クラスを使っています。

16:09
Now you can think of test case almost like Laravel. It makes and bootstraps Laravel for you.
> このTestCaseクラスがほぼLaravelだと思ってください。これがLaravelを作って起動します。

16:13
And you'll also see this commented line, RefreshDatabase.
> それからこのコメントアウトされている行に、RefreshDataseクラスがあります。

16:17
And what this means is after every test completes, Laravel will refresh and reset the database so that you start with a clean slate.
> これが何をするのかというと、すべてのテストが完了した後、まっさらな環境に戻すようにLaravelがデータベースを更新してリセットします。

16:25
Alright, so these things will be active in the feature folder right here, but I also want them in my unit folder.
> これらはこのFeatureフォルダーの中で使えるようになっているのですが、これを私はUnitフォルダでも使いたいのです。

16:32
And yeah, this goes back to how defferent people have different ideas for what a unit test should encompass, in my case, I'm pretty loose with it.
> これは、ユニットテストがどこまでを含むのかについて人それぞれの考え方があるという話に戻ってしまうのですが、私はその区別を曖昧にしておきます。

16:42
So I'm going to use these two parent classes or traits within the unit and the feature folder.
> ということで、これら２つの親クラスもしくはトレイトをUnitとFeatureの両方のフォルダで使用することにします。

16:49
All right, now if I run it again, it passes. Perfect.
> ではもう一度実行してみると。テストは成功です。完璧です。

16:53
So it passed, if I switch back, because we have already set up these relationships.
> 戻って確認すると、テストに合格したのは、これらのリレーションをすでに設定していたからです。

16:59
So if I go into job and we hadn't yet written this, we would run the test, it would fail. And at that point we could write the code in order to make it work.
> ですからJobクラスでこれを書いていなかったとしたら、テストを実行しても失敗します。そうなってから、このテストに成功するようにコードを書いていくこともできます。

17:08
And this is referred to as test-driven evelopment.
> これがテスト駆動開発と呼ばれるものです。

17:12
Yeah, I find that test-driven development can be a little confusing to newcomers, but it's actually not so bad, especially with Laravel these days.
> テスト駆動開発は初心者には少し難しいかと思いますが、実際は、特に最近のLaravelでやる分にはそんなに大変なものではありません。

17:20
Think of it like this.
> こんな風に考えてください。

17:21
You start by writing a test where you interact with the world and in this case the world is your code base.
> まず、ある世界とのやりとりを描いたテストを書くことから始めます。その世界とはあなたのコードです。

17:28
You interact with the world in a way that is ideal to you.
> そのコードが正しく理想的に動作するとして、その世界とのやりとりを書きます。

17:32
Next you run the test, but of course the test is going to fail, right? You haven't written any of this code in real life, you are in La-la-land, you're saying 'Wouldn't it be great if this worked?'. But of course it doesn't.
> 次にテストを実行します。でももちろんテストは失敗しますよね。実際にはまだコードを書いていないのですから。あなたはララランドにいて「これがちゃんと動いてくれたら」と言っているようなものです。でももちろんそんなことはありません。

17:44
So the test returns red. It fails.
> 当然テストは赤を返します。失敗です。

17:47
So the final step is write the code to make the test pass. And then rerun the test, it returns green and you rinse and recycle.
> 最後に、テストに合格するようにコードを書きます。それからテストを再実行すれば、緑色を返します。その後もコードを綺麗にしてテストするということを繰り返します。

17:56
It's a nice way to build applications.
> アプリケーションを構築するにはいい方法です。

17:58
It's not for everything but in certain scenarios you're really going to love it.
> あらゆる場面に適しているわけではありませんが、特定のシナリオでは本当に気に入るはずです。

18:02
Anyways, if we return this code and run the test again, it passes.
> とにかく、このコードを元に戻してテストを再実行すると、合格します。

18:08
Now I do want to show you at least one example of this TDD approach.
> ここで少なくともあと１つだけ、TDD(テスト駆動開発)のアプローチの例をお見せしたいと思います。

18:10
So how about a post can have tags. That can be useful.
> 投稿にタグがあったらいかがでしょうか。きっと便利なはずです。

18:14
So how about it can have tags?
> ということで、`it('can have tags')`としてみましょう。

18:18
Alright, let's follow Arrange, Act, Assert, create the world.
> ではArrange(準備して)、Act(実行して)、Assert(主張する)に従って、世界を構築しましょう。

18:21
Well, to start, I want a job. So job factory create.
> まずは求人が必要ですね。`Job::factory()->create()`とします。

18:26
All right, next, act. So interact with the world in the way that would be ideal.
> では次はAct(実行)です。理想的な世界とやりとりします。

18:32
So if I want to attach a tag to my job, maybe I could even call a method like tag. Job, tag it with frontend or something like that.
> ということで、求人にタグをつけたいと思います。おそらくtagというメソッドを呼ぶことになるでしょう。求人に’Frontend'といったタグをつけます。

18:41
Finally, assert. Assert that this worked the way I would expect. Maybe something like this.
> 最後にAssert(主張)です。私が思い描いた通りに動くと主張します。こんな感じです。

18:48
I would assume on my job model I would have a tags collection. And maybe I could say, well I expect that collection to have one item.
> Jobモデルにはタグのコレクションがあると仮定します。ですからおそらく、コレクションにはアイテムが１つあると期待することができます。

18:55
So I could say to have count one. And I'll reformat.
> ということで`toHaveCount(1)`と書くことができます。フォーマットしておきましょう。

19:01
Yeah, why don't we start with that?
> はい、ではこれで開始しましょう。

19:04
Alright, so let's come back and run our tests, and of course it fails. There is no method called tag.
> 戻ってテストを実行してみると、もちろん失敗します。tagというメソッドがありません。

19:10
All right, let's implement that. Job tag.
> では実装しましょう。Jobのtagです。

19:14
All right, so we fixed that particular error, it said no tag method exists, so we run it again, and now we have changed the error.
> はい、これでtagメソッドがないというエラーは修正しました。もう一度実行してみると、今度は別のエラーになりました。

19:21
And this is a key part of test driven development.
> これがテスト駆動開発のキーになるところです。

19:23
Make the error change.
> 「エラーを変化させろ」

19:25
And that is a signal that you are in fact making progress.
> エラーの内容が変われば、あなたの作業が一歩前進したということが分かります。

19:28
Okay? So now we tried to grab a collection but of course that returns null and it's not working.
> いいですか？これでコレクションを取り出そうとするようになりましたが、動いておらずnullが返されます。

19:34
Okay, let's do that now.
> 今度はこれを解決しましょう。

19:36
We will have a tags relationship. And why don't we just stub it out for now. Let's return an empty array.
> tagsというリレーションを用意します。今はこれを単なるスタブ（代用品、ダミー）にしましょう。空の配列を返します。

19:43
Alright? It fails, the error changes, and now, job tags must return an eloquent relationship instance.
> いいですか？これは失敗して、エラーが変わります。今度は、Job::tagsはEloquentのリレーションインスタンスを返さなければいけないとのことです。

19:50
Okay, now we can get to work.
> わかりました。やりましょう。

19:52
Let's make a model for a tag.
> Tagというモデルを作ります。

19:55
And I don't know if we're going to get around to building a controller for it, but I do want a factory and a migration.
> これのコントローラーを使うかどうかは分かりませんが、ファクトリーとマイグレーションは必要です。

20:01
All right? So let’s go into create tags table.
> いいですか？ではtagsテーブルを作りにいきましょう。

20:05
And this is very simple.
> これはとてもシンプルです。

20:07
A tag consists of a unique name, like frontend, backend, manager, project leader.
> タグにはユニークな名前が必要です。フロントエンドやバックエンド、管理者、プロジェクトリーダーなどです。

20:15
And actually for now, I think that's fine.
> 今はこれだけで十分でしょう。

20:17
All right, now let's go into TagFactory and set this up.
> では今度は、TagFactoryに移動して中身を実装します。

20:20
A TagFactory has a name of any kind of fake and unique, so I'll add that classifier, name and that will be fine.
> TagFactoryにはフェイクの名前を用意します。ユニークにしないといけないので、そういう識別子もつけましょう。これでいいですね。

20:30
All right, so now I can go into job, and yeah, let's update this relationship.
> それではJobに移動して、このリレーションを更新しましょう。

20:36
So does a job belong to a tag? Well that would signal that the tag owns the job, right?
> 求人はタグに属しますか？それはつまりタグが求人を所有しているということですね。

20:43
And no, that doesn't really make sense.
> それは違います。意味が通りません。

20:45
What about the inverse?
> その逆はどうでしょう？

20:47
Does the tag belong to the job?
> タグは求人に属しますか？

20:49
Well sort of, right? If I had a tag called frontend, that could belong to this job, the only thing is it could belong to more than one job. It could belong to 10 different jobs. So it's not exclusive.
> ある意味そうだといえます。フロントエンドというタグがあったとしたら、そのタグはこの求人に属していることがありえます。ただし属す求人は１つに限らないということです。10個の異なる求人に属すことがありえます。排他的ではないのです。

21:02
Okay, so in these situations, we want a belongs to many relationship. And we'll create a pivot table to allow for that.
> そのような場合は、belongsToManyリレーションになります。それを実現するためにピボットテーブルを作りましょう。

21:09
Alright? So our relationship is belongs to many. A job can belong to and have many tags.
> このリレーションはbelongsToManyとなります。求人はタグに属し、かつたくさんのタグを持つことができます。

21:18
Alright, so we have a tag eloquent model, we have a job eloquent model.
> これでタグのEloquentモデルと求人のEloquentモデルができました。

21:24
Next, we need an intermediate table.
> 次は、中間テーブルです。

21:25
And this table will include the job ID and the tag id. And I'll do that over and over.
That way one job could potentially have a hundred different tags that it is associated with.
> このテーブルには求人のIDとタグのIDが登録されます。これをいくつも繰り返すことで、求人は関連したタグを、たとえそれが１つにつき100個あろうと持つことができます。

21:37
Let's create a migration, php artisan make migration create job tag table.
> マイグレーションファイルを作成しましょう。`php artisan make:migration create_job_tag_table`を実行します。

21:44
All right?
> いいですか？

21:48
All right, so we want a foreign ID for the job, right?
> では、まず求人の外部キーが必要ですね。

21:52
And then we want another one for the tag.
> それからタグの外部キーも必要です。

21:56
And for both of these, why don't we say constrained? Create a foreign key constraint and then cascade on delete.
> それらの両方でconstrained()を呼び出しましょう。外部キー制約を作成し、cascadeOnDeleteを付けます。

22:03
And we've already reviewed both of these.
> これら２つは既にレビュー済みですね。

22:04
This just means if, in this example, if the tag is deleted, then cascade and also delete the record within this pivot table as well.
> これは単に、この例では、タグが削除されたらそれと一緒にこのピボットテーブルのレコードも削除するという意味です。

22:13
Okay. Php artisan migrate.
> では`php artisan migrate`を実行します。

22:17
So now I have a new tags table and a job tag pivot table.
> これで新しくtagsテーブルとjob_tabピボットテーブルができました。

22:22
Alright, so we've done some work, I'm now going to return to job test.
> さて、色々やり終えたので、JotTestに戻ります。

22:27
And let's see how we're doing. Php artisan test. And it still fails.
> どうなったか見てみましょう。`php artisan test`を実行すると、まだ失敗します。

22:32
Failed asserting that actual size zero matches expected size of one.
> 実際のサイズ0と期待されるサイズ1が一致しません。

22:37
Well at least we are making progress.
> 少なくとも前進はしています。

22:39
Let's go back into job and let's see.
> Jobに戻ってみてみましょう。

22:41
That relationship is working, but right now the tag method doesn't do anything at all.
> このリレーションは動作しています。ですがtagメソッドは何もしていません。

22:46
So let's update this.
> これを更新しましょう。

22:47
If I accept a tag name here, we'll call it name.
> ここでタグ名を受け取ります。変数名はnameにします。

22:53
Now there's a couple ways to do this.
> やり方はいくつかあります。

22:55
I'm going to reference the tag model.
> Tagモデルを参照します。

22:57
So I'm going to say give me the first tag from the database table that has this name.
> このように書きましょう。データベースからこの名前を持っている最初のタグをください。

23:03
Or if you couldn't find one with that name, create or persist one in that table.
> または、もしその名前が見つからなければ、作成してテーブルに保存します。

23:08
So I'm going to say the name is name.
> ということで`'name' => $name`と書きましょう。

23:11
Alright, does that make sense? Give me the tag from that table. And if you couldn't find the tag with that name, create one and then give me the tag.
> これで意味は通じていますか？テーブルからタグを取ってきてください。もしその名前で見つからなければ、作成してそのタグを渡してください。

23:18
Alright, next, I'm goingto iteract with my pivot table.
> では、次はピボットテーブルとのやりとりです。

23:21
I can say this tags and attach a new tag here. Just like that.
> このtagsに新しいタグを取り付ける、と書きます。こんな感じです。

23:27
Alright, finally these squiggly lines. My editor just wants return types.
> では、最後はこの波線です。私のエディターが戻り値の型を書くように警告しています。

23:31
Again, these are optional depending on how you like to build your applications, but we could import these and simplifies.
> 繰り返しになりますが、これは任意で、あなたがどのようにアプリケーションを構築したいかによります。これらはインポートして短くしておきます。

23:38
Alright, let's run our tests again.
> ではもう一度テストしてみましょう。

23:40
And it fails, but I want you to notie right here, yeah, check this out,
> 失敗しますが、ここを見てください。

23:44
Add name to the fillable property to allow mass assignment on tag.
> タグにマスアサインメントを許可するにはnameをfillableプロパティに追加してください。

23:48
Yes. So notice when we take this approach, it almost feels like the tests are telling you what the next thing you need to do is.
> はい、お気づきでしょうか。このアプローチ方法をとると、まるでテストがあなたが次にやるべきことを教えてくれているようです。

23:55
And that's one of the huge benefits to this approach.
> これがこのアプローチ方法における大きな利点の１つです。

23:57
All right, let's go on to tag. And we could update the fillable property.
> それではタグを開きましょう。ここでfillableプロパティを更新できます。

24:01
Or I'm going to go into app service provider and I'm going to disable that feature entirely like we've learned about in past videos.
> または、AppServiceProviderを開いて、以前の動画で学んだようにこの機能を全部無効化することもできます。

24:09
So I can say model unguard.
> その場合は、`Model::unguard()`とします。

24:13
All right, run it again.
> ではもう一度やってみましょう。

24:14
And now we get green. How cool is that. We haven't yet opened a browser, but now we know that a job belongs to an employer and it can be associated with any number of tags.
> 今度は緑になりました。クールじゃないですか。ブラウザを開いてもいないのに、求人が雇用主に属していること、そして複数のタグがつけられることが確認できたんです。

24:25
All right, let's be done with tests. That's all we can get done here.
> それではテストについては終わりにしましょう。ここでできるのはここまでです。

24:28
Let's go into our routes file.
> ルートファイルを開きましょう。

24:29
And yeah, all we have right now is the homepage route. Let's update this.
> 今あるのはホームページへのルートだけです。これを更新しましょう。

24:33
When you visit the homepage, that will load our new job controller and an index action on it.
> ホームページにアクセスすると、新しく作ったJobControllerのindexアクションを呼び出します。

24:41
All right, let's open that up.
> これを開きましょう。

24:43
And this can still load our welcome view, though we should probably change that, shouldn't we?
> これはまだウェルカムビューを開くようにすることができますが、変えた方がいいでしょう。

24:48
So let's go into resources, views, I'm going to have a directory called jobs, and then a view called index.blade.php.
> resouces/viewsの下にjobsというディレクトリを用意し、そこにindex.blade.phpを作成します。

24:57
And what I'll do is I'll take everything here and migrate it over and then I can delete welcome entirely.
> そして、これをすべてこちらに移動して、ウェルカムページを削除します。

25:03
All right, back to job controller.
> では、JobControllerにもどりましょう。

25:05
Now as you can imagine, and let's update this, we would need to pass jobs to our job listing page.
> お分かりかと思いますが、これは更新しておきましょう、求人一覧ページに求人データを渡す必要があります。

25:11
And I'm also imagining that we need to pass a list of tags. So let's do that one as well.
> それからタグのリストも渡す必要があるでしょう。これも同様にします。

25:16
All right, let's keep it very simple.
> ではシンプルにいきましょう。

25:17
We can now reference our job model and say, 'Give me all of them'. Though of course as we've learnd, in a real project we would want to paginate them. But for now, a select star is fine.
> Jobモデルを参照して「全部くれ」ということができます。ですがもちろん以前学習したように、実際のプロジェクトではページネーションを使いたくなると思います。でも今は全件検索でもいいでしょう。

25:28
We'll do the exact same thing for our tags.
> 同じことをタグにも行います。

25:31
Okay, let's go into our view, and you'll remember that, yeah, in the last episode everything was static. We're just hard coding all of these.
> ではビューに移動しましょう。覚えているかと思いますが、以前のエピソードではすべて固定値にしていました。これらはすべてハードコーディングしています。

25:38
But now we can swap them out.
> ですが、今度はこれらを入れ替えます。

25:40
Let's begin with, how about tags.
> タグから始めましょうか。

25:45
We can say for each tags as tag then render this blade component.
> `@foreach($tags as $tag)`として、このbladeコンポーネントをレンダリングします。

25:50
But now I want to pass in the associated tag. Like this, tag equals tag.
> ですが今度は、関連するタグを渡します。こんな風に`:tag="$tag"`とします。

25:58
Or a little tip in situations like this where your parameter name and the variable name are the same. If you prefer you can actually do this.
> もしくは、このようなときに使えるちょっとした技ですが、パラメータの名前と変数の名前が同じときは、お好みで`:$tag`とすることもできます。

26:07
This is just sort of syntactic sugar that achieves the exact same result.
> これはある種の糖衣構文で、全く同じ結果が得られます。

26:13
All right, so now within tag, I also need to accept the tag.
> そして今度はタグの中からも、同様にタグを受け取る必要があります。

26:17
And now I will swap out the text here with the name of the tag itself.
> 続いてここのテキストをタグの名前と置き換えましょう。

26:23
Next, we haven't set up an endpoint, but the href would probably be something like tags slash tag name to lowercase maybe.
> 次です。まだエンドポイントの設定は終わってませんが、hrefはおそらく、/tags/に続けてタグの名前を小文字にしたものになるでしょう。

26:33
Yeah, but we haven't set that up yet.
> できました。でもエンドポイントの設定はまだです。

26:35
Okay, let's go back to jobs index.
> ではjobs/indexに戻りましょう。

26:38
So we've updated this one here, but also we reference tags within the job cards, don't we?
> indexにあるタグは更新しましたが、タグは求人カードでも参照していましたよね。

26:44
This should be easy. Now we know a job can have tags.
> この修正は簡単です。求人にタグがあることは分かっています。

26:48
For each job tags as tag, then reference the tag.
> foreachで囲ってタグを参照します。

26:56
All right, let's copy this and then also switch back to job vard wide.
> では、これをコピーして横長の求人カードに移動しましょう。

27:01
And yeah, we have this one right here.
> ここにもあります。

27:04
Get rid of this and the size can be the default.
> これを取り除けばサイズをデフォルトにできます。

27:07
All right, let's view this in the browser.
> ではブラウザで見てみましょう。

27:10
Ah, yeah, of course. I jumped ahead of myself.
> ああそうでした、先を急ぎすぎました。

27:12
So within job card, we're referencing a variable called job that was not defined.
> 求人カードでjobという変数を参照していますが、まだそれを定義していませんでした。

27:17
Of course, each of these need to be updated to now accept the job.
> どちらも求人を受け取るように更新する必要があります。

27:23
So here's job card wide. I will then go into job card and paste that in.
> これは横長の求人カードですので、普通の求人カードの方にもこれを貼り付けましょう。

27:28
And then within our jobs slash index view, we can pass these in, in the exact same way, for each jobs as job, pass it in.
> それからjobs/indexビューからこれらを渡しましょう。同じようにforeachで囲って渡します。

27:42
All right, and then I'm going to do the same thing up here. But do note this is the feature jobs, so we will need to tweak this in just a little bit.
> そしてここにも同じことをしましょう。ですがこれは"注目の求人"なので、少しいじる必要があります。

27:50
But yeah, let's just get to a point where the page loads.
> ですが、とりあえずページがロードできるところまでにしておきましょう。

27:53
Alright, come back, cross our fingers, and the page is loading.
> では、戻って祈ってみると、ページがロードされました。

27:57
Now you'll notice of course we don't see any tags or jobs because we don't have any yet.
> タグも求人もどちらも表示されていませんね。まだ１つもないからです。

28:01
So this is where database seeders come into play.
> ここからがデータベースシーダーの出番です。

28:04
We'll go into database seeders, JobSeeder, and let's do this now. So yeah, this is sort like a whirlwind tour of the entire course up until this point.
> database/seeders/JobSeederに移動して取り掛かりましょう。そう、これはここまでの全コースを駆け足でめぐっているようなものです。

28:14
Job factory, let's create, I don't know 20 of them, create.
> Jobのfactoryメソッドで作成します。20個くらいにしましょうか。create()を呼びます。

28:20
Now keep in mind, this will work but it doesn't account for tags.
> ここで注意してください。これは機能しますが、タグのことを考慮していません。

28:24
So here's what we'll do. I'm also going to say tag tactory three, create.
> そこでこのようにします。同じようにTagのfactoryに3を指定してcreateメソッドを呼びます。

28:30
So I'm going to create a collection of three random tags.
> こうして３つのランダムなタグの集合を作成します。

28:33
And now I'm going to call a new method you haven't seen called has attached. And of course, this is for belongs to many relationships. I want to attach these tags to each of these jobs we generate.
> ここで、まだみなさんがご存じないhasAtttachedというメソッドを呼び出します。これはもちろんbolongsToManyリレーションのためです。ここで作成した求人のそれぞれにこれらのタグをつけたいと思います。

28:45
So now every single job will consist of these three tags.
> これで各求人にこれら３つのタグがつけられます。

28:50
All right, let's go to database seeder. I will create our dummy user, that's fine. And then we will call our job seeder.
> それではDatabaseSeederを開きましょう。ダミーユーザを作るのはいいですね。それからJobSeederを呼び出します。

28:59
All right, let's give it a shot, php artisan db:seed.
> では実行してみましょう。`php artisan db:seed`を実行します。

29:03
If I come back to TablePlus, yeah, now we have a bunch of employers, we have a bunch of jobs, and we have three tags, and whoops, I accidentally did a person's name instead of a word. I'll fix that.
> TablePlusに戻ってみると、たくさんの雇用主と、たくさんの求人、そして３つのタグができていますが、しまった、間違ってタグ名にwordではなく人の名前をつけてしまいました。後で修正します。

29:15
But anyways, three tags that each of these jobs are associated with, and we can see those references here.
> でもとにかく、これらの求人につけられた３つのタグができ、そのリレーションがここで確認できます。

29:23
All right, let's fix that real quick.
> では、さっさとさっきのを修正しましょう。

29:25
Tag factory, and let's use a dummy word here.
> TagFactoryを開き、ここでダミーのwordを使います。

29:30
All right, php artisan migrate fresh dash dash seed, reset my migrations, rerun them, and then seed the database.
> `php artisan migrate:fresh --seed`を実行してマイグレーションをリセットし、やり直してから、データベースのシーディングを行います。

29:38
Let's go to arc, give it a refresh. And now we have actual live data coming from our database.
> 作成中のサイトに戻って更新します。これでデータベースから取得した実際のデータが表示されました。

29:46
Pretty cool.
> とてもクールです。

29:48
And then we have three tags and notice every single job is associated with them.
> そしてタグが３つあり、どの求人にもそれらがついています。

29:54
Okay? So just a couple final things.
> いいですか？それでは最後にもう１～２つだけ。

29:58
I'm going to go into job card and make all of these dynamic.
> 求人カードを開いて、これらすべてを動的にしたいと思います。

30:01
So we'll say job, employer name. We want job title, job salary, and then tag, we no longer have to pass this in.
> `$job->employer->name`とし、`$job->title`に`$job->salary`も必要です。そしてタグはもう渡す必要はありません。

30:14
And then employer logo, we're going to come back to that.
> それから雇用主のロゴですが、これは後で行います。

30:17
Okay, now let's go to the wide version of the card, and I'm going to do the exact same thing, job employer
> 今度は横長のカードです。同じことを行います。`$job->employer`とします。

30:23
So notice we do have an N plus one issue right now, because we haven't eager loaded the employer relationship. So for each item in this loop, we have to perform a new query to fetch the employer. So keep that in mind.
> 注意してください。ここにはあのN+1問題があります。雇用主のリレーションをイーガーロードしていないからです。ですからこのループのアイテムごとに雇用主を取得するクエリ－を実行する必要があります。これを忘れないで下さい。

30:35
Job title, job salary, and same thing here.
> `$job->title`に`$job->salary`、そしてここも同じです。

30:43
All right, back to arc.
> ではサイトで確認します。

30:45
And now these are unique the way we'd expect.
> これでやりたかったとおりユニークになりました。

30:48
Okay, so the last thing I can fit in here is feature jobs.
> さて、最後に調整するのは注目の求人です。

30:52
Right now we're getting the exact same collection.
> 今ここにはまったく同じリストが並んでいます。

30:55
So notice the first one is psychiatric technician. And then if I come down here to recent jobs, we see the exact same thing.
> 最初は精神科医です。そしてこの下にある最近の求人を見てみると、全く同じであることが分かります。

31:01
There is no distinction between a featured job and a non or un featured job.
> 取り上げられているの求人と取り上げられていない求人の間に違いはありません。

31:08
Let's do this. I'm going to come back to our job seeder.
> こうしましょう。JobSeederに戻ります。

31:13
And we know that in some cases we could set featured defaults and other cases featured to true.
> ある場合にはfeaturedをデフォルトにセットし、それ以外ではtrueにセットすることができます。

31:19
So I could run two separate queries, or this is a slightly more advanced concept, but we could create a sequence intead.
> ですので２つのクエリ－を別々に実行することもできますし、これは少し高度になりますが、代わりにシーケンスを作ることもできます。

31:27
And it takes this shape, new sequence.
> それはこのような形になります。`new Sequence()`。

31:31
And notice that full import there.
> インポートされているフルパスに注意してください。

31:33
I'm going to provide a sequence of parameters that I want Laravel to filter through, or better iterate through.
> 連続したパラメータを渡します。それをLaravelに選択というか反復してもらいます。

31:43
For example, sometimes featured will be set to false.
> 例えば、ときどきfeaturedをfalseにセットします。

31:46
And why don't we set schedule to full-time.
> それからスケジュールをフルタイムにしましょう。

31:50
All right? But then in the next iteration featured will be set to true, and a schedule will be set to part-time.
> いいですか？でも次の繰り返しではfeaturedはtrueにし、スケジュールはパートタイムにしましょう。

31:58
All right, so let's reformat.
> ではフォーマットしなおして、

32:00
And if we did everything correctly, we should now have for a total of 20, 10 of them with these attribute override set, and another 10 with these attributes.
> うまくいっていれば、これで全部で20個の求人ができ、そのうち10個の属性はこれで上書きされ、別の10個はこの属性になるはずです。

32:09
Let's give it a shot. I will run migrate fresh seed. And now check this out.
> 動かしてみましょう。`migrate:fresh --seed`を実行します。これを確認しましょう。

32:14
I'm going to go into job controller and let's extract this.
> JobControllerに移動して、これを取り出しましょう。

32:21
Call it jobs. All right.
> 取り出したものは$jobsとします。

32:22
And I'm going to say job all, but after we fetch them, I want to group them according to whether or not they are featured.
> `Job::all()`で取り出しますが、そのあと、注目されているかどうかでグループ分けしたいと思います。

32:30
So check this out. I'm going to return this from the controller so that we can review the json.
> これを確認しましょう。これをコントローラから返せば、それをJSON形式で確認することができます。

32:37
And let's see, let's do pretty print.
> では見てみましょう。Pretty-print機能で整形します。

32:39
All right, so notice we have a collection of collections now.
> コレクションのコレクションがあります。

32:43
So for the first array in every case featured is set to zero.
> 最初の配列では、どれもfeaturedが0にセットされています。

32:47
But after we get to 10 or so, we get a new array or a new collection.
> ですが、10個ほど続いたあとには、新しい配列もしくはコレクションが出てきます。

32:52
And for this one featured is set to one for all of the items.
> こちらではすべてのアイテムのfeaturedは1にセットされています。

32:58
So we have grouped these into collections based upon whether or not they are featured.
> つまり、注目されているかどうかによってグループ分けされたコレクションが手に入ります。

33:03
Cool, so now here's what we could do.
> クールですね。そこでこのようにすることができます。

33:05
We could, uh, let's do this. We'll have featured jobs as well.
> えっと、こうしましょう。注目の求人を別に受け取るようにします。

33:10
So that's the first item from this collection here.
> これはこのコレクションの最初の要素になりますね。

33:14
And the second item is the un-featured jobs.
> そして２番目の要素が取り上げられていない求人です。

33:16
So if we want, yeah, we could do something like that.
> はい、このようにすることができます。

33:20
All right, so let's go into our view. And now I can loop over featured jobs instead.
> ではビューに移りましょう。ここはfeaturedJobを代わりに繰り返すようにできます。

33:27
Okay, so now down here, this will be standard jobs. And you know what? This probably isn't quite right because presumably you would want featured jobs included with your recent jobs.
> するとこの下の方は通常の求人となります。でもちょっと聞いてください。これは本当にやりたいこととはちょっと違います。注目の求人はこの最近の求人の方にも含まれて欲しいですよね。

33:37
But yeah, for now we're just drawing a distinction between promoted jobs and non-promoted jobs.
> でも今は、取り上げられている求人とそうでないものを区別して表したいだけなんです。

33:42
So as to avoid duplication
> だから重複しないようにしています。

33:45
Okay, so back to arc.
> ではサイトで確認しましょう。

33:47
Alright, so now we have our 10 featured jobs, beggining with human resource director, 3, 6, 9, 10.
> はい、今度は注目の求人が10個取り上げられています。人事部長から始まって、3, 6, 9, 10個あります。

33:54
Then our tags and then un-featured jobs. And this one is human resources assistant. It's a defferent collection entirely.
> 続いてタグと注目されていない求人です。そしてこれは人事アシスタントですね。全部別のコレクションになっています。

34:02
Very cool.
> とてもクールです。

34:05
Alright, that's a wrap.
> はい、これで終了です。

34:06
And I'm not even joking, I am literally tired right now.
> 冗談ではなく、私は今本当に疲れています。

34:09
There's just so much to cover, and oh my gosh, we only have one more video to do it. So wish me luck.
> カバーすべきことはまだたくさんありますが、何てことでしょう、あと１回の動画でそれをやらなくてはいけません。幸運を祈ってください。

34:15
Tomorrow is day 30 and we're going to wrap up this entire course.
> 明日は30日目です。これで全てのコースが終了します。

34:20
I'll see you then.
> それでは、また。

34:24
Put your arms in the air. You'll never take me alive!
>「手を挙げろ！」「捕まえられると思うなよ！」
